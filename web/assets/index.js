// ——— State ———
let uplcWasm = null;
let starkBg = null;
let aikenWasm = null;
let starkProofBytes = null;
let starkVkBytes = null;
let lastEvalResult = null;
let lastUserPublicValues = null;
let backendAvailable = false;
let activeTab = 'aiken';
let aikenCompiled = false;
let proveAbort = null;   // AbortController for in-flight prove request
let proveGeneration = 0; // bumped each run to detect stale callbacks
let busy = false;        // true while an async action is running
// Aggregation STARK verifying key, generated by `cargo openvm setup` and
// committed in web/data/agg_stark.vk.  Constant per OpenVM toolchain version.
let aggVkBytes = null;

// Step completion state (indices 0-3 for steps 1-4)
const stepDone = [false, false, false, false];

// ——— Client-side proof processing ———
import { constructVmStarkVk, processProof, initZstd } from './proof-utils.js';
import { highlightAiken } from './aiken-highlight.js';

async function loadAggVk() {
  try {
    const resp = await fetch('/data/agg_stark.vk');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const buf = await resp.arrayBuffer();
    aggVkBytes = new Uint8Array(buf);
    console.log(`Loaded agg_stark.vk: ${aggVkBytes.length} bytes`);
  } catch (e) {
    console.warn('Failed to load agg_stark.vk:', e);
  }
}

async function loadZstd() {
  try {
    await initZstd();
    console.log('zstd-codec initialized');
  } catch (e) {
    console.warn('Failed to initialize zstd-codec:', e);
  }
}

// ——— WASM Loading ———

async function loadUplcWasm() {
  try {
    const mod = await import('../uplc/uplc_wasm.js');
    await mod.default();
    uplcWasm = mod;
    setStatus('uplcStatus', 'ready', 'UPLC WASM');
    updateSteps();
  } catch (e) {
    setStatus('uplcStatus', 'error', 'UPLC WASM');
  }
}

async function loadAikenWasm() {
  try {
    const mod = await import('../aiken/aiken_wasm.js');
    await mod.default();
    aikenWasm = mod;
    setStatus('aikenStatus', 'ready', 'Aiken WASM');
    document.getElementById('compileBtn').disabled = false;
  } catch (e) {
    setStatus('aikenStatus', 'error', 'Aiken WASM');
  }
}

async function checkBackend() {
  try {
    const resp = await fetch('/api/health', { signal: AbortSignal.timeout(3000) });
    if (resp.ok) {
      backendAvailable = true;
      setStatus('backendStatus', 'ready', 'Backend');
      updateSteps();
    } else {
      throw new Error('not ok');
    }
  } catch (e) {
    backendAvailable = false;
    setStatus('backendStatus', 'error', 'Backend');
    updateSteps();
  }
}

async function loadStarkWasm() {
  try {
    const starkModule = await import('../openvm-verifier/openvm_wasm_stark_verifier.js');
    await starkModule.default();
    starkBg = starkModule;
    setStatus('starkStatus', 'ready', 'STARK Verifier');
    updateSteps();
  } catch (e) {
    setStatus('starkStatus', 'error', 'STARK Verifier');
  }
}

function setStatus(id, state, label) {
  const el = document.getElementById(id);
  el.className = `status-badge ${state}`;
  const dot = state === 'ready' ? '&#x2713;' : state === 'error' ? '&#x2717;' : '<span class="status-dot"></span>';
  el.innerHTML = `${dot} ${label}`;
}

function isStep1Complete() {
  if (activeTab === 'aiken') return aikenCompiled;
  return document.getElementById('programHex').value.trim() !== '';
}

function updateSteps() {
  const s1ok = isStep1Complete();
  stepDone[0] = s1ok;

  // Step 1 card: always enabled
  setCardState('card1', true, s1ok);

  // Step 2: enabled if step 1 complete + UPLC WASM + backend
  const s2ready = s1ok && uplcWasm && backendAvailable;
  setCardState('card2', s2ready, stepDone[1]);
  document.getElementById('evalProveBtn').disabled = busy || !s2ready;

  // Step 3: enabled if step 2 done
  setCardState('card3', stepDone[1], stepDone[2]);
  document.getElementById('commitBtn').disabled = busy || !stepDone[1];

  // Step 4: enabled if step 3 done and proof+VK available
  const s4ready = stepDone[2] && starkProofBytes && starkVkBytes;
  setCardState('card4', stepDone[2], stepDone[3]);
  document.getElementById('starkBtn').disabled = busy || !s4ready;

  // Compile button (step 0)
  document.getElementById('compileBtn').disabled = busy || !aikenWasm;

  // Pipeline indicators
  for (let i = 1; i <= 4; i++) {
    const el = document.getElementById(`pipeStep${i}`);
    el.classList.remove('active', 'done', 'fail');
    if (stepDone[i - 1]) el.classList.add('done');
  }
  for (let i = 1; i <= 3; i++) {
    const el = document.getElementById(`pipeConn${i}`);
    el.classList.remove('done', 'fail');
    if (stepDone[i - 1]) el.classList.add('done');
  }

  // Verdict
  if (stepDone[3]) showVerdict(true);
}

function setCardState(id, enabled, done) {
  const el = document.getElementById(id);
  el.classList.toggle('disabled', !enabled);
  el.classList.toggle('done', !!done);
  el.classList.remove('fail');
}

function setCardFail(id) {
  const el = document.getElementById(id);
  el.classList.remove('done');
  el.classList.add('fail');
}

function resetFrom(step) {
  for (let i = step; i < 4; i++) stepDone[i] = false;
  if (step <= 1) {
    // Cancel any in-flight prove request
    if (proveAbort) { proveAbort.abort(); proveAbort = null; }
    proveGeneration++;
    busy = false;
    lastEvalResult = null;
    lastUserPublicValues = null;
    starkProofBytes = null;
    starkVkBytes = null;
    hideResult('evalResult');
    hideResult('proveResult');
    document.getElementById('downloadRow').style.display = 'none';
    document.getElementById('proofInfo').textContent = '';
    document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
  }
  if (step <= 2) hideResult('commitResult');
  if (step <= 3) hideResult('starkResult');
  document.getElementById('verdict').className = 'verdict';
  updateSteps();
}

function hideResult(id) {
  document.getElementById(id).className = 'result-box';
}

function switchTab(tab) {
  activeTab = tab;
  document.getElementById('tabBtnAiken').classList.toggle('active', tab === 'aiken');
  document.getElementById('tabBtnUplcHex').classList.toggle('active', tab === 'uplcHex');
  document.getElementById('tabAiken').classList.toggle('active', tab === 'aiken');
  document.getElementById('tabUplcHex').classList.toggle('active', tab === 'uplcHex');
  resetFrom(1);
  updateSteps();
};

// ——— Aiken Compilation ———

async function compileAiken() {
  if (!aikenWasm) return;
  const source = document.getElementById('aikenSource').value;
  if (!source.trim()) return showResult('compileResult', 'error', 'Please enter Aiken source code.');

  resetFrom(1);

  const btn = document.getElementById('compileBtn');
  btn.disabled = true;
  document.getElementById('compileBtnText').innerHTML = '<span class="spinner"></span> Compiling…';

  await new Promise(resolve => setTimeout(resolve, 0));

  try {
    const t0 = performance.now();
    const hex = aikenWasm.compile_to_uplc_hex(source);
    const dt = performance.now() - t0;
    document.getElementById('programHex').value = hex;
    aikenCompiled = true;
    updateSteps();
    showResult('compileResult', 'success',
      `<div class="result-label">Compiled to UPLC</div>` +
      `<div class="result-value">${hex.length > 120 ? hex.slice(0, 120) + '…' : hex}</div>` +
      `<div class="timing">Compiled in ${dt.toFixed(1)} ms &mdash; ${hex.length / 2} bytes flat</div>`
    );
  } catch (e) {
    aikenCompiled = false;
    updateSteps();
    showResult('compileResult', 'error',
      `<div class="result-label">Compilation Failed</div>` +
      `<div class="result-value">${escapeHtml(String(e))}</div>`
    );
  }
  btn.disabled = false;
  document.getElementById('compileBtnText').textContent = 'Compile';
};

// ——— Step 2: Evaluation & Proof Generation ———

async function runEvaluateAndProve() {
  const hex = document.getElementById('programHex').value.trim();
  if (!hex) return;

  resetFrom(1);
  const myGeneration = ++proveGeneration;
  const abort = new AbortController();
  proveAbort = abort;

  busy = true;
  updateSteps();
  document.getElementById('evalProveBtnText').innerHTML = '<span class="spinner"></span> Evaluating & Proving…';
  setPipeActive(2);

  // 1. Local WASM evaluation
  let evalResult;
  try {
    const t0 = performance.now();
    evalResult = uplcWasm.evaluate_uplc(hex);
    const dt = performance.now() - t0;
    lastEvalResult = evalResult;
    showResult('evalResult', 'success',
      `<div class="result-label">Evaluation Result</div>` +
      `<div class="result-value">${escapeHtml(evalResult)}</div>` +
      `<div class="timing">Evaluated in ${dt.toFixed(1)} ms</div>`
    );
    document.getElementById('expectedResult').value = evalResult;
  } catch (e) {
    setPipeFail(2);
    setCardFail('card2');
    showResult('evalResult', 'error',
      `<div class="result-label">Evaluation Failed</div>` +
      `<div class="result-value">${escapeHtml(String(e))}</div>`
    );
    busy = false;
    updateSteps();
    document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
    return;
  }

  // 2. Request proof generation from backend
  showResult('proveResult', 'info',
    `<div class="result-label">Proof Generation</div>` +
    `<div class="result-value">Generating STARK proof on server… this may take a while.</div>`
  );

  try {
    const resp = await fetch('/api/prove', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ program_hex: hex }),
      signal: abort.signal,
    });
    if (myGeneration !== proveGeneration) return; // stale
    const data = await resp.json();

    if (!data.success) {
      setPipeFail(2);
      setCardFail('card2');
      showResult('proveResult', 'error',
        `<div class="result-label">Proof Generation Failed</div>` +
        `<div class="result-value">${escapeHtml(data.error || 'Unknown error')}</div>`
      );
      busy = false;
      updateSteps();
      document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
      return;
    }

    const duration = data.duration_secs ? data.duration_secs.toFixed(1) : '?';

    // Check we have the raw proof JSON from backend
    if (!data.stark_proof_json) {
      showResult('proveResult', 'warning',
        `<div class="result-label">Warning</div>` +
        `<div class="result-value">Missing proof data from backend</div>`
      );
      stepDone[1] = true;
      busy = false;
      updateSteps();
      document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
      return;
    }

    try {
      // Ensure zstd is ready (no-op if already initialized at startup)
      await initZstd();
      if (myGeneration !== proveGeneration) return; // stale

      // Process proof client-side: hex decode + concat + zstd compress
      showResult('proveResult', 'info',
        `<div class="result-label">Processing proof locally…</div>` +
        `<div class="result-value">STARK proof generated in ${duration}s. Converting for verification…</div>`
      );

      const { compressedProof, userPublicValuesHex } = processProof(data.stark_proof_json);
      starkProofBytes = compressedProof;
      lastUserPublicValues = userPublicValuesHex;

      // Construct VK client-side from agg_stark.vk + app commits
      if (aggVkBytes && data.app_exe_commit && data.app_vm_commit) {
        starkVkBytes = constructVmStarkVk(aggVkBytes, data.app_exe_commit, data.app_vm_commit);
      } else {
        starkVkBytes = null;
        console.warn('Cannot construct VK:', !aggVkBytes ? 'missing agg_stark.vk' : 'missing commits');
      }

      // Update proof info
      const vkInfo = starkVkBytes ? `VK: ${fmtBytes(starkVkBytes.length)}` : 'VK: not available';
      document.getElementById('proofInfo').textContent =
        `Proof loaded: ${fmtBytes(starkProofBytes.length)}. ${vkInfo}.`;

      showResult('proveResult', 'success',
        `<div class="result-label">Proof Generated &amp; Processed</div>` +
        `<div class="result-value">STARK proof generated in ${duration}s</div>` +
        `<div class="timing">Proof: ${fmtBytes(starkProofBytes.length)}` +
        (starkVkBytes ? `, VK: ${fmtBytes(starkVkBytes.length)}` : '') + `</div>`
      );
    } catch (processError) {
      setPipeFail(2);
      setCardFail('card2');
      showResult('proveResult', 'error',
        `<div class="result-label">Proof Processing Failed</div>` +
        `<div class="result-value">${escapeHtml(String(processError))}</div>`
      );
      busy = false;
      updateSteps();
      document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
      return;
    }

    // Fill commitment
    if (data.commitment) {
      document.getElementById('expectedCommitment').value = data.commitment;
    }

    // Download buttons
    if (data.commitment) {
      const blob = new Blob([data.commitment], { type: 'text/plain' });
      document.getElementById('dlCommitment').href = URL.createObjectURL(blob);
    }
    if (starkProofBytes) {
      const blob = new Blob([starkProofBytes], { type: 'application/octet-stream' });
      document.getElementById('dlProof').href = URL.createObjectURL(blob);
    }
    if (data.commitment || starkProofBytes) {
      document.getElementById('downloadRow').style.display = 'flex';
    }

    // Mark step 2 done
    stepDone[1] = true;
    updateSteps();

  } catch (e) {
    if (e.name === 'AbortError' || myGeneration !== proveGeneration) return; // cancelled
    setPipeFail(2);
    setCardFail('card2');
    showResult('proveResult', 'error',
      `<div class="result-label">Request Failed</div>` +
      `<div class="result-value">${escapeHtml(String(e))}</div>`
    );
  }

  if (myGeneration !== proveGeneration) return; // stale
  busy = false;
  updateSteps();
  document.getElementById('evalProveBtnText').textContent = 'Evaluate & Prove';
};

// ——— Step 3: Commitment Verification ———

function runCommitmentCheck() {
  if (!uplcWasm || lastEvalResult === null) {
    return showResult('commitResult', 'error', 'Run Evaluate & Prove first.');
  }

  resetFrom(2);

  const hex = document.getElementById('programHex').value.trim();
  const expectedResult = document.getElementById('expectedResult').value.trim();
  const expectedCommitment = document.getElementById('expectedCommitment').value.trim().toLowerCase();

  setPipeActive(3);

  if (expectedResult && expectedResult !== lastEvalResult) {
    setPipeFail(3);
    stepDone[2] = false;
    setCardFail('card3');
    updateSteps();
    showResult('commitResult', 'error',
      `<div class="result-label">Result Mismatch</div>` +
      `<div>Expected result: ${escapeHtml(expectedResult)}</div>` +
      `<div>Actual result: &nbsp;${escapeHtml(lastEvalResult)}</div>`
    );
    return;
  }

  try {
    const resultForCommitment = expectedResult || lastEvalResult;
    const t0 = performance.now();
    const computed = uplcWasm.compute_commitment(hex, resultForCommitment);
    const dt = performance.now() - t0;

    let details = '';
    if (expectedResult) {
      details += `<div style="margin-bottom:6px">&#x2705; Result matches: <strong>${escapeHtml(expectedResult)}</strong></div>`;
    }

    if (!expectedCommitment) {
      stepDone[2] = true;
      updateSteps();
      showResult('commitResult', 'info',
        details +
        `<div class="result-label">Computed Commitment (SHA-256)</div>` +
        `<div class="result-value">${computed}</div>` +
        `<div class="timing">Computed in ${dt.toFixed(1)} ms</div>`
      );
    } else if (computed === expectedCommitment) {
      stepDone[2] = true;
      updateSteps();
      showResult('commitResult', 'success',
        details +
        `<div class="result-label">Commitment Match</div>` +
        `<div class="result-value">${computed}</div>` +
        `<div class="timing">Verified in ${dt.toFixed(1)} ms</div>`
      );
    } else {
      stepDone[2] = false;
      setPipeFail(3);
      setCardFail('card3');
      updateSteps();
      showResult('commitResult', 'error',
        details +
        `<div class="result-label">Commitment Mismatch</div>` +
        `<div>Expected: ${escapeHtml(expectedCommitment)}</div>` +
        `<div>Computed: ${computed}</div>`
      );
    }
  } catch (e) {
    stepDone[2] = false;
    setPipeFail(3);
    setCardFail('card3');
    updateSteps();
    showResult('commitResult', 'error', escapeHtml(String(e)));
  }
};

// ——— Step 4: STARK Verification ———

async function runStarkVerification() {
  if (!starkBg) {
    return showResult('starkResult', 'error', 'STARK verifier WASM not loaded.');
  }
  if (!starkProofBytes) {
    return showResult('starkResult', 'error', 'Proof not available. Run Evaluate & Prove first.');
  }
  if (!starkVkBytes) {
    return showResult('starkResult', 'error', 'Verification key not available. Check that agg_stark.vk is loaded and app commits are present.');
  }

  resetFrom(3);

  busy = true;
  updateSteps();
  const btn = document.getElementById('starkBtn');
  setPipeActive(4);
  showResult('starkResult', 'info',
    `<div class="result-label">STARK Verification</div>` +
    `<div class="result-value">Verifying proof client-side via WASM… this may take a moment.</div>`
  );

  // Yield to allow UI to update
  await new Promise(resolve => setTimeout(resolve, 50));

  try {
    const t0 = performance.now();
    const result = starkBg.verify_stark(starkProofBytes, starkVkBytes);
    const dt = performance.now() - t0;

    if (result) {
      stepDone[3] = true;
      updateSteps();

      let pvHtml = '';
      if (lastUserPublicValues) {
        pvHtml = `<div class="public-values">` +
          `<div class="pv-label">Proof public values &mdash; SHA-256( program || result )</div>` +
          `<div class="pv-value">${lastUserPublicValues}</div>` +
          `</div>`;
      }

      showResult('starkResult', 'success',
        `<div class="result-label">STARK Proof Verified</div>` +
        `<div class="result-value">Client-side WASM verification confirmed the proof is valid.</div>` +
        `<div class="timing">Verified in ${(dt / 1000).toFixed(1)}s</div>` +
        pvHtml
      );
    } else {
      setPipeFail(4);
      setCardFail('card4');
      showResult('starkResult', 'error',
        `<div class="result-label">STARK Verification Failed</div>` +
        `<div class="result-value">verify_stark returned false.</div>`
      );
    }
  } catch (e) {
    setPipeFail(4);
    setCardFail('card4');
    showResult('starkResult', 'error',
      `<div class="result-label">STARK Verification Error</div>` +
      `<div class="result-value">${escapeHtml(String(e))}</div>`
    );
  }

  btn.disabled = false;
  busy = false;
  updateSteps();
};

// ——— Pipeline helpers ———

function setPipeActive(step) {
  const el = document.getElementById(`pipeStep${step}`);
  el.classList.remove('done', 'fail');
  el.classList.add('active');
}

function setPipeFail(step) {
  const el = document.getElementById(`pipeStep${step}`);
  el.classList.remove('active', 'done');
  el.classList.add('fail');
}

// ——— Helpers ———

function showResult(id, type, html) {
  const el = document.getElementById(id);
  el.className = `result-box visible ${type}`;
  el.innerHTML = html;
}

function showVerdict(pass) {
  const v = document.getElementById('verdict');
  v.className = `verdict visible ${pass ? 'pass' : 'fail'}`;
  v.innerHTML = pass
    ? `<div class="verdict-icon">&#x2705;</div><h3>Verification Passed</h3><p>The UPLC program was honestly evaluated inside the OpenVM zkVM.<br><span style="font-size:0.75rem;color:var(--text-muted)">Evaluation, commitment check, and STARK verification all ran locally in your browser via WASM.</span></p>`
    : `<div class="verdict-icon">&#x274C;</div><h3>Verification Failed</h3><p>The proof could not be verified.</p>`;
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function fmtBytes(n) {
  if (n < 1024) return n + ' B';
  if (n < 1048576) return (n/1024).toFixed(1) + ' KB';
  return (n/1048576).toFixed(1) + ' MB';
}

// ——— Aiken editor highlighting ———

function syncHighlight() {
  const src = document.getElementById('aikenSource').value;
  // Append a newline so the <pre> always has room for the last line
  document.getElementById('aikenHighlight').innerHTML = highlightAiken(src) + '\n';
}

function syncScroll() {
  const ta = document.getElementById('aikenSource');
  const pre = document.getElementById('aikenHighlight').parentElement;
  pre.scrollTop = ta.scrollTop;
  pre.scrollLeft = ta.scrollLeft;
}

// ——— Init ———

const aikenTA = document.getElementById('aikenSource');
aikenTA.addEventListener('input', () => {
  aikenCompiled = false;
  resetFrom(1);
  syncHighlight();
});
aikenTA.addEventListener('scroll', syncScroll);

// Handle Tab key for indentation
aikenTA.addEventListener('keydown', (e) => {
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = aikenTA.selectionStart;
    const end = aikenTA.selectionEnd;
    aikenTA.value = aikenTA.value.substring(0, start) + '  ' + aikenTA.value.substring(end);
    aikenTA.selectionStart = aikenTA.selectionEnd = start + 2;
    syncHighlight();
  }
});

// Initial highlight
syncHighlight();

document.getElementById('programHex').addEventListener('input', () => {
  resetFrom(1);
  updateSteps();
});

// Button event listeners
document.getElementById('tabBtnAiken').addEventListener('click', () => switchTab('aiken'));
document.getElementById('tabBtnUplcHex').addEventListener('click', () => switchTab('uplcHex'));
document.getElementById('compileBtn').addEventListener('click', compileAiken);
document.getElementById('evalProveBtn').addEventListener('click', runEvaluateAndProve);
document.getElementById('commitBtn').addEventListener('click', runCommitmentCheck);
document.getElementById('starkBtn').addEventListener('click', runStarkVerification);

loadUplcWasm();
loadAikenWasm();
loadStarkWasm();
loadAggVk();
loadZstd();
checkBackend();
updateSteps();
